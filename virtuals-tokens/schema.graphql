type TokenLaunch @entity {
  id: ID!
  address: String! # The launched token address as string for search
  addressBytes: Bytes! # The raw token address bytes
  createdAtBlock: BigInt!
  createdAtTx: Bytes!
  tokenCreator: String! # Creator address as string for search
  tokenCreatorBytes: Bytes! # The raw creator address bytes
  timestamp: BigInt!
  
  # Launch function parameters
  name: String!
  ticker: String!
  cores: [Int!]!
  description: String!
  imageUrl: String!
  urls: [String!]!
  purchaseAmount: BigInt!
}

type Swap @entity(immutable: true) {
  id: Bytes! # Transaction hash
  timestamp: BigInt!
  block: BigInt!
  trader: Bytes!
  tokenIn: Bytes!
  tokenOut: Bytes!
  amountIn: BigInt!
  amountOut: BigInt!
  feeAmount: BigInt!
  feeRecipient: Bytes!
  type: String! # "BUY" or "SELL"
}

type TokenDayData @entity(immutable: true) {
  id: Bytes!          # Concatenated token address and timestamp
  token: Bytes!       # Token address
  date: BigInt!       # Unix timestamp for start of day
  
  # Price metrics
  priceUSD: BigDecimal!
  priceUSDHigh: BigDecimal!
  priceUSDLow: BigDecimal!
  priceUSDChange: BigDecimal!
  
  # Volume metrics
  volumeToken: BigDecimal!
  volumeUSD: BigDecimal!
  volumeUSDChange: BigDecimal! # 24h change
  
  # Trade metrics
  txCount: Int!
  buyCount: Int!
  sellCount: Int!
  
  # Unique metrics
  uniqueTraders: Int!
  
  # Market metrics
  marketCap: BigDecimal!
  totalSupply: BigDecimal!
  
  # Liquidity metrics
  tvlUSD: BigDecimal!
  liquidityUSD: BigDecimal!
}

type TokenTraderDayData @entity(immutable: true) {
  id: Bytes! # Concatenated token address, day timestamp, and trader address
}

type _Schema_
@fulltext(
  name: "tokenLaunchSearch"
  language: en
  algorithm: rank
  include: [
    {
      entity: "TokenLaunch",
      fields: [
        { name: "address" },
        { name: "tokenCreator" },
        { name: "name" },
        { name: "ticker" },
        { name: "description" }
      ]
    }
  ]
)

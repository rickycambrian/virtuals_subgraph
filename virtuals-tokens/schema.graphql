type TokenLaunch @entity {
  id: ID!
  address: String! # The launched token address as string for search
  addressBytes: Bytes! # The raw token address bytes
  createdAtBlock: BigInt!
  createdAtTx: Bytes!
  tokenCreator: String! # Creator address as string for search
  tokenCreatorBytes: Bytes! # The raw creator address bytes
  timestamp: BigInt!
  
  # Launch function parameters
  name: String!
  ticker: String!
  cores: [Int!]!
  description: String!
  imageUrl: String!
  urls: [String!]!
  purchaseAmount: BigInt!
}

type Swap @entity {
  id: Bytes! # Transaction hash
  timestamp: BigInt!
  block: BigInt!
  trader: Bytes!
  tokenIn: Bytes!
  tokenOut: Bytes!
  amountIn: BigInt!
  amountOut: BigInt!
  feeAmount: BigInt!
  feeRecipient: Bytes!
  type: String! # "BUY" or "SELL"
}

type SwapData @entity(timeseries: true) {
  id: Int8!
  timestamp: Timestamp!
  token: Bytes!          # Token address
  amountToken: BigDecimal!
  amountUSD: BigDecimal!
  type: String!         # "BUY" or "SELL"
  trader: Bytes!
  isBuy: Int! # 1 for buy, 0 for sell
  isSell: Int! # 1 for sell, 0 for buy
  traderCount: Int! # Always 1, used for counting unique traders
}

type TokenStats @aggregation(intervals: ["hour", "day"], source: "SwapData") {
  id: Int8!
  timestamp: Timestamp!
  token: Bytes!
  
  # Volume metrics
  volumeToken: BigDecimal! @aggregate(fn: "sum", arg: "amountToken")
  volumeUSD: BigDecimal! @aggregate(fn: "sum", arg: "amountUSD")
  
  # Price metrics
  priceUSD: BigDecimal! @aggregate(fn: "last", arg: "amountUSD / amountToken")
  highPriceUSD: BigDecimal! @aggregate(fn: "max", arg: "amountUSD / amountToken")
  lowPriceUSD: BigDecimal! @aggregate(fn: "min", arg: "amountUSD / amountToken")
  
  # Trade metrics
  tradeCount: Int! @aggregate(fn: "sum", arg: "traderCount")
  buyCount: Int! @aggregate(fn: "sum", arg: "isBuy")
  sellCount: Int! @aggregate(fn: "sum", arg: "isSell")
  
  # Average trade size (total volume / trade count)
  avgTradeSize: BigDecimal! @aggregate(fn: "sum", arg: "amountToken / traderCount")
}

type _Schema_
@fulltext(
  name: "tokenLaunchSearch"
  language: en
  algorithm: rank
  include: [
    {
      entity: "TokenLaunch",
      fields: [
        { name: "address" },
        { name: "tokenCreator" },
        { name: "name" },
        { name: "ticker" },
        { name: "description" }
      ]
    }
  ]
)
